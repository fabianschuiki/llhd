/* Copyright (c) 2014-2015 Fabian Schuiki */
#include "llhd/unicode/casefolding.hpp"
#include "llhd/unicode/utf.hpp"
#include "src/unicode/casefolding-internal.hpp"

namespace llhd {
namespace unicode {

/// \addtogroup unicode
/// @{


/// Used by lookup() to advance the search through the *_nodes table by 8 bits.
static unsigned resolve_base(const uint32_t* nodes, unsigned base, utf8char c) {
	base = nodes[base + ((c >> 4) & 0xF)];
	if (base == 0)
		return 0;
	return nodes[base + (c & 0xF)];
}

/// Used by lookup() to advance the search through the *_nodes table by 16 bits.
static unsigned resolve_base(const uint32_t* nodes, unsigned base, utf16char c) {
	base = resolve_base(nodes, base, (utf8char)(c >> 8));
	if (base == 0)
		return 0;
	return resolve_base(nodes, base, (utf8char)c);
}

/// Used by lookup() to advance the search through the *_nodes table by 32 bits.
static unsigned resolve_base(const uint32_t* nodes, unsigned base, utf32char c) {
	base = resolve_base(nodes, base, (utf16char)(c >> 16));
	if (base == 0)
		return 0;
	return resolve_base(nodes, base, (utf16char)c);
}


/// Looks up a casefolded equivalent of \a c in the table \a nodes and \a
/// leaves.
///
/// \param  c  Character to lookup the casefolded equivalent for.
/// \param  nodes  The *_nodes table generated by tblgen-casefolding to search.
/// \param  leaves  The *_leaves table generated by tblgen-casefolding to
///         search.
/// \param  shift  Set to the width of the character \a c in case an equivalent
///         was found. May be NULL.
/// \return The pointer \a c if no casefolded equivalent was found. Otherwise a
///         pointer to the null-terminated replacement sequence is returned.
template<typename T, typename L>
static const T* lookup(
	const T* c,
	const uint32_t* nodes,
	const L* leaves,
	unsigned* shift) {

	const T* c0 = c;
	unsigned base = 0;
	do {
		base = resolve_base(nodes, base, *c);
		c++;
		if (base & 0x8000) {
			if (shift)
				*shift = c-c0;
			return leaves + (base ^ 0x8000);
		}
	} while (base != 0 && *c != 0);

	return c0;
}


/// \name Specializations of casefold
/// @{
/// A specialization for a *simple* and a *full* casefolding is provided for
/// \ref utf8char, \ref utf16char, and \ref utf32char. These use the tables
/// generated by \ref casefolding-tablegen.cpp.

template<> const utf8char*
casefold<utf8char,true>(const utf8char* c, unsigned* shift) {
	if (utf8::is_trail(*c))
		return c;
	return lookup(c, utf8_full_nodes, utf8_full_leaves, shift);
}

template<> const utf8char*
casefold<utf8char,false>(const utf8char* c, unsigned* shift) {
	if (utf8::is_trail(*c))
		return c;
	return lookup(c, utf8_simple_nodes, utf8_simple_leaves, shift);
}


template<> const utf16char*
casefold<utf16char,true>(const utf16char* c, unsigned* shift) {
	if (utf16::is_trail(*c))
		return c;
	return lookup(c, utf16_full_nodes, utf16_full_leaves, shift);
}

template<> const utf16char*
casefold<utf16char,false>(const utf16char* c, unsigned* shift) {
	if (utf16::is_trail(*c))
		return c;
	return lookup(c, utf16_simple_nodes, utf16_simple_leaves, shift);
}


template<> const utf32char*
casefold<utf32char,true>(const utf32char* c, unsigned* shift) {
	return lookup(c, utf32_full_nodes, utf32_full_leaves, shift);
}

template<> const utf32char*
casefold<utf32char,false>(const utf32char* c, unsigned* shift) {
	return lookup(c, utf32_simple_nodes, utf32_simple_leaves, shift);
}
/// @}


/// @}

} // namespace unicode
} // namespace llhd
